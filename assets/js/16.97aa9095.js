(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{225:function(t,a,v){"use strict";v.r(a);var _=v(0),r=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"递归小记"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#递归小记"}},[t._v("#")]),t._v(" 递归小记")]),t._v(" "),v("h2",{attrs:{id:"递归算法的思想："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#递归算法的思想："}},[t._v("#")]),t._v(" 递归算法的思想：")]),t._v(" "),v("p",[t._v("将 "),v("strong",[t._v("对较大规模的对象的操作")]),t._v(" 归结为 "),v("strong",[t._v("对较小规模的对象实施同样的操作")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"递归元："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#递归元："}},[t._v("#")]),t._v(" 递归元：")]),t._v(" "),v("p",[t._v("这种规模的变化就体现在递归算法的变元中的一类（一个或几个）变元上，这类变元被称之为递归元。")]),t._v(" "),v("h3",{attrs:{id:"递归元要满足两个条件："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#递归元要满足两个条件："}},[t._v("#")]),t._v(" 递归元要满足两个条件：")]),t._v(" "),v("ul",[v("li",[t._v("递归元的变化是在递归定义中确定的。")]),t._v(" "),v("li",[t._v("递归元的变化应能导致递归算法的终止。")])]),t._v(" "),v("h2",{attrs:{id:"常见的递归形式："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的递归形式："}},[t._v("#")]),t._v(" 常见的递归形式：")]),t._v(" "),v("ul",[v("li",[t._v("多变元递归\n递归元多于一个的递归")]),t._v(" "),v("li",[t._v("多步递归\n递归函数f(x,n)。其中y是递归元，不仅与f(x,n-1)有关，而且和f(x,n-2),... ...，乃至f(x,0)有关，则称为多步递归。")]),t._v(" "),v("li",[t._v("嵌套递归\n递归调用中又含有递归调用， 又称为多重递归。")]),t._v(" "),v("li",[t._v("联立递归 *\n我们有几个递归函数，彼此相互调用，从而形成递归，又称间接递归。\n把几个子函数结合起来，形成联立递归，参考Hiber图")])]),t._v(" "),v("blockquote",[v("p",[t._v("递归算法一定要有一个或几个最简单情况的计算（非递归分支），如果缺少将造成递归不终止。")])]),t._v(" "),v("blockquote",[v("p",[t._v("递归算法是有层次的，低层的解组合成高层的解。各层间最好通过参数传递来交流信息，如果使用全局量，则要注意全局量的及时修订。")])]),t._v(" "),v("p",[v("strong",[t._v("至少要有一个递归在不断的减小。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);