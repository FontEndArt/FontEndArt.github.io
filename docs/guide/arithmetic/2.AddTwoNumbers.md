# 2.两数相加

## 题目
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/add-two-numbers
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

示例：
```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    // do some things...
};
```

## 错解题意
由于审题不清，我们很容易得到以下思路：

- 题目：两数相加
- 参数：
    + l1: ListNode
    + l2: ListNode
- 结果：
    + result: ListNode

所以就会沿着自己的思路下来，得到以下错误的题解：

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    // do some things...
};
```

---

> 希望大家针对算法的题目，切记要审题清晰，多读几遍没毛病的。一旦题意不明，写再多的代码都的不到正确答案。

## 正确题解方法
- 题目：两数之和
- 参数：
    + nums: number[]
    + target: number
- 结果：
    + number[]
- **假设**：
    + 每种输入只会对应一个答案
    + 不能重复利用这个数组中同样的元素（return的时候不可以出现`[4, 4]`这样索引一致的结果）

下面是我提供的几种解法:

### 解法一：双for暴力破解法

#### 思路

我们对数组进行遍历，并从遍历项索引值+1的项开始第二层循环。类似于排列组合`C(nums.length, 2)`。
在这里是`C(4, 2) = (4*3) / (2*1) = 6`; 也可以直接看下图：

![双层for循环图](https://github.com/FontEndArt/blog/blob/master/images/arithmetic/TwoSum_double_for.png?raw=true)

[排列组合-百度百科](https://baike.baidu.com/item/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/706498?fr=aladdin#2_1 "排列组合-百度百科")

#### 代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    for (var i = 0; i < nums.length; i++) {
        for (var j = i+1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [nums[i], nums[j]];
            }
        }
    }
    return [];
};
```

这种方法虽然让我们完成了题解，阅读起来也清晰明了。但是这种方法的时间复杂度为O(n!)，属于效率低下的一种方法，所以我们在开发时间允许的情况下，需要去寻找一种时间复杂度更低的算法。

### 解法二：空间换时间

#### 思路

我们对数组进行遍历，遍历每一项的时候都进行期望值判断 `target - nums[i]` (其中 i 是当前数组的索引)是否在之前遍历过了，如果存在则直接返回即可。如果不存在，我们将其存起来，然后继续遍历下一项。

#### 代码

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    var n = nums.length;
    var mapper = {};
    for (var i = 0; i < n; i++) {
        if (target - nums[i] in mapper) {
            return [mapper[target - nums[i]], i];
        } else {
            mapper[nums[i]] = i;
        }
    }
};

// 或

var twoSum = function(nums, target) {
    const map = new Map();
    for (let i = 0; i < nums.length; i ++) {
        const otherIndex = map.get(target - nums[i]);
        if (otherIndex !== undefined) return [otherIndex, i];
        map.set(nums[i], i);
    }
};

```

这种方法能够在线性的时间内完成，但是相应地我们使用了额外的 O(n) 空间，这在很多情况下是值得的，不但可以使代码实现该算法，而且`mapper`中的数据天然有序，因为`mapper`的键值对为`value => index`(value和index为nums中的每一项的值和索引)。

## 致谢

感谢大家阅读我的文章，如果对我感兴趣可以关注我的博客，或者点击页面右上角帮我点个star。

[前端小然子的博客](https://xiaoranzife.com "前端小然子")


